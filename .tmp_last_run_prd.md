## System Boundaries

Das System operiert als **Single-User Desktop-Webanwendung** vollständig client-seitig im Browser ohne Backend-Server-Infrastruktur. Die Laufzeitumgebung basiert auf **sql.js (SQLite WebAssembly)**, wobei die Datenpersistenz über **IndexedDB** als virtuelles Dateisystem erfolgt. Diese Architektur ermöglicht einen statischen Export (Static Site Generation) und Zero-Deployment-Kosten, schränkt jedoch den verfügbaren Speicherplatz auf 5–50 MB je nach Browser ein.

Das System unterstützt **zwei diskrete, typ-spezifische Workflows** mit validierten Status-Transitionen (State Machine Pattern). Für Bugs existiert ein linearer Workflow: `offen` → `in_bearbeitung` → `testen` → `erledigt` → `geschlossen`, mit Sondertransitionen von jedem Status zurück zu `offen` (Reopen-Funktionalität). Für Ideen gilt ein flexiblerer Product-Workflow: `backlog` → `evaluation` → `geplant` → `in_arbeit` → `umgesetzt` → `archiviert`. Status-Werte sind als Enums definiert; freie Texteingaben oder ad-hoc-Transitionen sind systemseitig ausgeschlossen.

Die UI-Schicht implementiert **zwei komplementäre Ansichtsmodi** mit persistentem User-Preference-Switch: Eine Kanban-Ansicht (Default für aktive Arbeit) mit Status-Spalten und Drag-and-Drop-Interaktion sowie eine Listen-Ansicht für Suchoperationen, Bulk-Actions und Archivzugriff mit sortierbaren Spalten. Die Ansichtsauswahl wird im localStorage persistiert; Suchergebnisse werden unabhängig von der Hauptansicht immer in Listenformat dargestellt.

Ein **4-stufiges Prioritätssystem** (P0-Kritisch, P1-Hoch, P2-Mittel, P3-Niedrig) mit visueller Farbkodierung und Icons ist systemweit implementiert. Die Default-Sortierung erfolgt nach `Priority ASC, createdAt DESC`; Multi-Column-Sorting ist via Spaltenheader-Interaktion möglich.

Technische Grenzen: Die Anwendung ist explizit nicht für Multi-User-Szenarien oder serverseitige Datenhaltung konzipiert. Eine spätere Cloud-Sync-Erweiterung erfordert einen Database Adapter Layer, der aktuell sql.js im Browser kapselt und zukünftig HTTP-APIs unterstützen könnte. Die Architektur unterstützt Offline-First-Betrieb via Service Worker (PWA-fähig), setzt aber voraus, dass der Benutzer moderne Browser mit WebAssembly-Unterstützung verwendet.

## Domain Model

- Kern-Entitaeten: Nutzer/Besucher, Feature, Anforderung und Iteration.
- Beziehungen: Eine Anforderung aggregiert Features; jede Iteration verfeinert bestehende Features und kann neue ueber ein strukturiertes Delta hinzufuegen.
- Datenkonsistenz: Feature-IDs bleiben ueber Iterationen stabil und gelten als unveraenderliche Kennungen.
- Quellkontext (Iteration 1): erstelle eine umfassende todoliste webapp für mich in welcher ich code bugs und neue ideen erfassen kann welche ich beim testen gefunden habe. ich brauche eine spalte NR, Name, Beschreibung, Status.die bugs und ideen müs

## Global Business Rules

- Bestehende Features duerfen waehrend der iterativen Verfeinerung nicht entfernt werden.
- Neue Features werden nur ueber validiertes Feature-Delta-JSON akzeptiert.
- Doppelte Features (gleiche Intention/Bezeichnung) werden deterministisch verworfen.
- Akzeptanzkriterien aller Features muessen testbar und beobachtbar bleiben.

## Functional Feature Catalogue

### F-01: Create Bug Entry
- Erfassen neuer Bug-Eintraege mit NR, Name, Beschreibung, Status und Prioritaet.

### F-02: Create Idea Entry
- Erfassen neuer Ideen-Eintraege mit NR, Name, Beschreibung, Status und Prioritaet.

### F-03: View and Search Entries
- Uebersichtliche Darstellung aller Eintraege inklusive Suche, Sortierung und Status-Filter.

### F-04: Edit Entry
- Bearbeiten bestehender Bugs/Ideen mit Validierung und konsistenter Statuslogik.

### F-05: Delete Entry
- Loeschen eines Eintrags mit Bestaetigungsdialog, Undo-Toast und konfigurierbarem Soft/Hard-Delete-Verhalten.

### F-06: Dashboard Overview
- Kennzahlen fuer Bugs/Ideen nach Status, Prioritaet und Verlauf.

### F-07: Data Export
- Export von Eintraegen als JSON/CSV fuer Review und Archivierung.

### F-08: Local Persistence & Recovery
- Zuverlaessige lokale Persistenz inklusive Wiederherstellung nach Reload/Crash.

---

## Feature ID: F-05
## Feature Name: Delete Entry

1. Purpose
Enable users to remove unwanted bug reports or idea entries safely, while preventing accidental loss.

2. Actors
- Single user of the application (local usage)

3. Trigger
User clicks the delete action button/icon associated with a specific bug or idea entry in the list view.

4. Preconditions
- At least one entry exists.
- The list view is loaded and interactive.

5. Main Flow
1. User selects delete on a specific entry.
2. System opens a confirmation modal with entry name and risk notice.
3. User confirms deletion.
4. System executes configured delete mode:
   - Soft delete: mark record as deleted and hide from default views.
   - Hard delete: physically remove record.
5. UI refreshes list and shows success toast with undo action.

6. Alternate Flows
- User cancels deletion in modal; nothing changes.
- Deletion request fails; UI shows error toast and keeps entry visible.
- Undo is triggered within toast window; entry is restored.

7. Postconditions
- Entry is deleted (soft or hard per configuration) or restored if undo is used in time.
- UI state and persisted state remain consistent.

8. Data Impact
- Soft delete stores a deletion flag/timestamp.
- Hard delete removes the row permanently.
- Audit metadata records delete source and time.

9. UI Impact
- Confirmation modal before destructive action.
- Success toast with undo action.
- Visible state update in list/dashboard.

10. Acceptance Criteria
- [ ] Deletion always requires explicit confirmation.
- [ ] User can cancel without side effects.
- [ ] Soft/hard delete behavior matches configured mode.
- [ ] Success toast appears after deletion and offers undo.
- [ ] Undo restores the same entry payload and visibility.
- [ ] Error handling keeps data and UI consistent.

## Non-Functional Requirements

- Performance: Initial load under 2s on standard desktop hardware.
- Reliability: No accepted feature is lost across compiler iterations.
- Security: Input validation, output sanitization, and least-privilege configuration.
- Accessibility: WCAG 2.1 AA for core workflows.
- Scalability: Compiler processing supports increasing feature counts without structural drift.
- Observability: Diagnostics include feature counts, dedupe actions, and fallback reasons.

## Deployment & Infrastructure

- Runtime: Node.js service with iterative compiler endpoints.
- Environment: Dockerized local/dev setup with reproducible builds and health endpoint.
- Dependencies: LLM provider integration with model fallback strategy.
- Delivery: TypeScript check and end-to-end API smoke run before release.

### F-07 — Übersicht / Dashboard

**1. Purpose**
Bietet einen schnellen Überblick über alle Bugs und Ideen mit Statistiken.

**2. Actors**
- Alle Benutzer

**3. Trigger**
- Anwendungsstart
- Klick auf Dashboard-Tab

**4. Preconditions**
- Datenbank enthält Daten

**5. Main Flow**
1. Dashboard lädt Statistiken
2. Zeigt: Offene Bugs, Erledigte Bugs, Ideen im Backlog, abgeschlossene Ideen
3. Zeigt: Letzte Aktivitäten
4. Zeigt: Trend-Diagramm (optional)

**6. Alternate Flows**
- Keine Daten: Leere-State mit Willkommens-Nachricht

**7. Postconditions**
- Dashboard ist geladen

**8. Data Impact**
- Aggregierte Queries (COUNT, GROUP BY)

**9. UI Impact**
- Glassmorphismus-Karten für Statistiken
- Animierte Zahlen
- Farbcodierte Status-Übersicht

**10. Acceptance Criteria**
- [ ] Statistiken sind korrekt
- [ ] Dashboard lädt schnell
- [ ] Visuell ansprechend

---

### F-08 — Datenexport

**1. Purpose**
Ermöglicht den Export aller Bugs und Ideen als CSV oder JSON.

**2. Actors**
- Alle Benutzer

**3. Trigger**
- Klick auf Export-Button
- Tastenkombination

**4. Preconditions**
- Mindestens ein Item existiert

**5. Main Flow**
1. Benutzer klickt Export
2. Format-Auswahl (CSV/JSON)
3. System generiert Datei
4. Download startet automatisch

**6. Alternate Flows**
- Keine Daten: Warnmeldung

**7. Postconditions**
- Datei wurde heruntergeladen

**8. Data Impact**
- Nur Lesen

**9. UI Impact**
- Export-Button im Header
- Format-Dropdown

**10. Acceptance Criteria**
- [ ] CSV-Export funktioniert
- [ ] JSON-Export funktioniert
- [ ] Alle Felder sind enthalten

---

Feature ID: F-10
Feature Name: Shadow Depth Effects

---

## Feature Specification: Priority System

**Feature ID:** F-17
**Feature Name:** Priority System

---

## Part A — System Context

### System Vision

Eine moderne, visuell beeindruckende Web-Anwendung zur Erfassung und Verwaltung von Code-Bugs und neuen Ideen, die beim Testen entdeckt werden. Die App kombiniert eine "umwerfende" Glassmorphismus-GUI mit perfekter Usability und lokaler SQLite-Datenspeicherung für maximale Privatsphäre und Offline-Fähigkeit.

### System Boundaries & Operating Model

- **Deployment**: Next.js Web-Anwendung (Single-Page Application)
- **Runtime**: Client-seitig mit Server-seitiger API für Datenbankzugriffe
- **Online/Offline**: Primär offline-fähig (lokale SQLite), mit optionaler Cloud-Sync-Erweiterbarkeit
- **Single/Multi-User**: Single-User Anwendung (lokaler Speicher)
- **Persistence**: Lokale SQLite-Datenbank (better-sqlite3 oder SQLite über Prisma)
- **Integrationen**: Keine externen Integrationen erforderlich

---

## Part C — UI/UX Design Specification

### Design Philosophy

**Glassmorphismus & Frost Glass**
- Hintergrund: Farbverläufe basierend auf Primärfarben (#2b336a, #870010, #7c7c6b)
- Glass-Elemente: `backdrop-filter: blur(16px)`, `background: rgba(255,255,255,0.1)`
- Border: `1px solid rgba(255,255,255,0.2)`
- Shadow: `0 8px 32px rgba(0,0,0,0.37)`

**Hover Effects**
- Scale: `transform: scale(1.02)`
- Shadow verstärken
- Border-Helligkeit erhöhen
- Transition: `all 0.3s cubic-bezier(0.4, 0, 0.2, 1)`

**Farbpalette**
- Primär Blau: #2b336a (RGB: 43, 51, 106)
- Primär Rot: #870010 (RGB: 135, 0, 16)
- Primär Grau: #7c7c6b (RGB: 124, 124, 107)
- Akzent: Gold/Gelb für Ideen
- Text: Weiß (#ffffff) auf dunklem Hintergrund
- Sekundär-Text: rgba(255,255,255,0.7)

### Layout

- **Header**: Glassmorphismus-Leiste mit Logo, Suchfeld, Export-Button
- **Sidebar/Tabs**: Navigation zwischen Bugs, Ideen, Dashboard
- **Main Content**: Liste/Kanban-Ansicht mit Glass-Karten
- **Modals**: Zentrierte Glass-Elemente mit Backdrop-Blur

---

## Part D — Technical Specification

### Tech Stack

- **Framework**: Next.js 14+ (App Router)
- **UI Library**: React 18+
- **Styling**: Tailwind CSS
- **Components**: Shad/cn (Radix UI)
- **Database**: SQLite (better-sqlite3 oder Prisma + SQLite)
- **State Management**: React Query oder Zustand
- **Icons**: Lucide React

### Database Schema (Prisma)

```prisma
model Item {
  id          String   @id @default(cuid())
  name        String
  description String
  type        String   // "bug" | "idee"
  status      String   // "offen" | "in_progress" | "erledigt" | "backlog" | "in_arbeit" | "umgesetzt"
  priority    String?  // "niedrig" | "mittel" | "hoch" | "kritisch"
  category    String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
```

---

---

```json
{
  "addedFeatures": [
    { "featureId": "F-01", "name": "Bug erfassen", "shortDescription": "Erfassung neuer Bugs mit Name, Beschreibung und Priorität" },
    { "featureId": "F-02", "name": "Idee erfassen", "shortDescription": "Erfassung neuer Ideen/Features" },
    { "featureId": "F-03", "name": "Status wechseln", "shortDescription": "Status von Items ändern via Dropdown oder Buttons" },
    { "featureId": "F-04", "name": "Item bearbeiten", "shortDescription": "Nachträgliche Änderung aller Felder" },
    { "featureId": "F-05", "name": "Item löschen", "shortDescription": "Löschen mit Bestätigung und Undo-Option" },
    { "featureId": "F-06", "name": "Filterung und Suche", "shortDescription": "Echtzeit-Suche und Status/Typ-Filter" },
    { "featureId": "F-07", "name": "Übersicht / Dashboard", "shortDescription": "Statistiken und Überblick über alle Items" },
    { "featureId": "F-08", "name": "Datenexport", "shortDescription": "Export als CSV oder JSON" }
  ],
  "updatedFeatures": []
}
```


